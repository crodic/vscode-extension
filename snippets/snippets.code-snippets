{
    "căn giữa các phần tử": {
        "prefix": "!fc",
        "body": ["display: flex;", "justify-content: center;", "align-items: center;"],
        "description": "căn giữa các phần tử"
    },
    "Bo Tròn Phần Tử": {
        "prefix": "!ic",
        "body": ["width: ${1:100%};", "height: ${1:100%};", "border-radius: 100rem;"],
        "description": "Tạo Hình Tròn"
    },
    "Dấu Chấm Lửng": {
        "prefix": "!ltext",
        "body": [
            "overflow: hidden;",
            "display: -webkit-box;",
            "-webkit-box-orient: vertical;",
            "-webkit-line-clamp: ${1:1};"
        ],
        "description": "Giới Hạn Số Hàng Của Text Trong 1 Phần Tử"
    },
    "Tạo Store Zustand": {
        "prefix": "!zus",
        "body": [
            "import { create } from 'zustand';",
            "import { immer } from 'zustand/middleware/immer';",
            "import { persist, createJSONStorage } from 'zustand/middleware';",
            "",
            "export const useStoreImmerPersist = create(",
            "    persist(",
            "        immer((set) => ({",
            "            count: 0,",
            "            updateCount: (number) =>",
            "                set((state) => {",
            "                    state.count = number;",
            "                })",
            "        })),",
            "        {",
            "            name: ${2:store},",
            "            storage: createJSONStorage(() => ${1:localStorage}),",
            "        }",
            "    )",
            ");"
        ],
        "description": "Tạo Store Zustand Với Thư Viện Immer"
    },
    "React Component": {
        "prefix": "!rafc",
        "body": [
            "const ${1:Component} = () => {",
            "    return <>",
            "      ${1:Component}",
            "    </>;",
            "}",
            "",
            "export default ${1:Component};"
        ],
        "description": "React Component"
    },
    "Mẫu Button 1: Animation Hover Scale Echo": {
        "prefix": "!tw-btn-1",
        "body": [
            "<button className=\"relative overflow-visible rounded-full hover:-translate-y-1 px-12 py-2 shadow-xl bg-background/30 after:content-[''] after:absolute after:rounded-full after:inset-0 after:bg-background/40 after:z-[-1] after:transition after:!duration-500 hover:after:scale-150 hover:after:opacity-0\">",
            "    ${1:Content}",
            "</button>"
        ],
        "description": "Mẫu Button 1: Animation Hover Scale Echo"
    },
    "Bắt sự kiện click ra bên ngoài phần tử": {
        "prefix": "!useClickOutSide",
        "body": [
            "import { useEffect } from \"react\";",
            "",
            "const useClickOutSide = (ref, callback) => {",
            "    const handleClickOutSide = (e) => {",
            "        if (ref?.current && !ref.current.contains(e.target)) {",
            "            callback();",
            "        }",
            "    };",
            "",
            "    useEffect(() => {",
            "        document.addEventListener(\"click\", handleClickOutSide);",
            "",
            "        return () => document.removeEventListener(\"click\", handleClickOutSide);",
            "    }, [ref, callback]);",
            "};",
            "",
            "export default useClickOutSide;",
            ""
        ],
        "description": "Bắt sự kiện click ra bên ngoài phần tử"
    },
    "Delay 1 sự kiện đến 1 khoản thời gian không hành động nhất định": {
        "prefix": "!useDebounce",
        "body": [
            "import { useEffect } from \"react\";",
            "import { useState } from \"react\";",
            "",
            "const useDebounce = (value, delay = 300) => {",
            "    const [valueDebounce, setValueDebounce] = useState(value);",
            "",
            "    useEffect(() => {",
            "        let handler = setTimeout(() => {",
            "            setValueDebounce(value);",
            "        }, delay);",
            "",
            "        return () => clearTimeout(handler);",
            "    }, [value, delay]);",
            "",
            "    return valueDebounce;",
            "};",
            "",
            "export default useDebounce;",
            ""
        ],
        "description": "Delay 1 sự kiện đến 1 khoản thời gian không hành động nhất định"
    },
    "Bắt sự kiện khi view thay đổi": {
        "prefix": "!useWindowSize",
        "body": [
            "import { useEffect } from \"react\";",
            "import { useState } from \"react\";",
            "",
            "const useWindowSize = () => {",
            "    const isClient = typeof window === \"object\";",
            "",
            "    const getSize = () => {",
            "        return {",
            "            width: isClient ? window.innerWidth : undefined,",
            "            height: isClient ? window.innerHeight : undefined,",
            "        };",
            "    };",
            "",
            "    const [windowSize, setWindowSize] = useState(getSize);",
            "",
            "    useEffect(() => {",
            "        if (!isClient) return false;",
            "",
            "        window.addEventListener(\"resize\", handleResize);",
            "",
            "        return () => removeEventListener(\"resize\", handleResize);",
            "    }, []);",
            "",
            "    const handleResize = () => {",
            "        setWindowSize(getSize());",
            "    };",
            "",
            "    return windowSize;",
            "};",
            "",
            "export default useWindowSize;",
            ""
        ],
        "description": "Bắt sự kiện khi view thay đổi"
    },
    "useAuthAxios() hook": {
        "prefix": "!useAuthAxios",
        "body": [
            "'use client';",
            "",
            "import { authAxios } from '@/services/axios/auth';",
            "import { useSession } from 'next-auth/react';",
            "import { useEffect } from 'react';",
            "",
            "const useAuthAxios = () => {",
            "    const { data: session } = useSession();",
            "",
            "    useEffect(() => {",
            "        const res = authAxios.interceptors.request.use(",
            "            (config) => {",
            "                if (!config.headers['Authorization']) {",
            "                    config.headers['Authorization'] = `Bearer ${session?.user.email}`;",
            "                }",
            "                return config;",
            "            },",
            "            (error) => Promise.reject(error)",
            "        );",
            "",
            "        const req = authAxios.interceptors.response.use(",
            "            (response) => {",
            "                return response;",
            "            },",
            "            async (error) => {",
            "                const prevRequest: any = error?.config;",
            "                if (error?.response?.status === 401 && !prevRequest.sent) {",
            "                    prevRequest.sent = true;",
            "                    let refresh = 'adsdasdas';",
            "                    prevRequest.headers['Authorization'] = `Bearer ${refresh}`;",
            "                    return authAxios(prevRequest);",
            "                }",
            "                return Promise.reject(error);",
            "            }",
            "        );",
            "",
            "        return () => {",
            "            authAxios.interceptors.request.eject(res);",
            "            authAxios.interceptors.response.eject(req);",
            "        };",
            "    }, [session]);",
            "",
            "    return authAxios;",
            "};",
            "",
            "export default useAuthAxios;",
            ""
        ],
        "description": "useAuthAxios() hook"
    },
    "Custom Axios Interceptors": {
        "prefix": "!i-axios",
        "body": [
            "import axios from 'axios';",
            "",
            "const ${1:Axios} = axios.create({",
            "    baseURL: ${2:\"\"},",
            "    timeout: ${3:20000},",
            "});",
            "",
            "${1:Axios}.interceptors.request.use(",
            "    (config) => {",
            "        return config;",
            "    },",
            "    function (error) {",
            "        return Promise.reject(error);",
            "    }",
            ");",
            "",
            "${1:Axios}.interceptors.response.use(",
            "    (response) => {",
            "        return response;",
            "    },",
            "    function (error) {",
            "        return Promise.reject(error);",
            "    }",
            ");",
            "",
            "export default ${1:Axios};",
            ""
        ],
        "description": "Custom Axios Interceptors"
    },
    "Persist Redux": {
        "prefix": "!rdux-p",
        "body": [
            "import sessionStorage from 'redux-persist/es/storage/session';",
            "import storage from 'redux-persist/lib/storage';",
            "",
            "export const ${1:persistApp} = {",
            "    key: '${2:app}',",
            "    storage,",
            "    whiteList: [],",
            "};"
        ],
        "description": "Persist Store Redux"
    },
    "RTK Query Middleware": {
        "prefix": "!rdux-midd",
        "body": [
            "import { isRejectedWithValue } from '@reduxjs/toolkit';",
            "import { toast } from 'react-toastify';",
            "",
            "export const rtkQueryErrorLogger = (api) => (next) => (action) => {",
            "    if (isRejectedWithValue(action)) {",
            "        console.warn('We got a rejected action!');",
            "        toast.warn({ title: 'Async error!', message: action.error.data.message });",
            "    }",
            "",
            "    return next(action);",
            "};",
            ""
        ],
        "description": "RTK Query Middleware"
    },
    "Create Slice In Redux Toolkit": {
        "prefix": "!rdux-sl",
        "body": [
            "import { createSlice } from '@reduxjs/toolkit';",
            "",
            "const ${1:name} = createSlice({",
            "    name: '${1:pathname}',",
            "    initialState: { },",
            "    reducers: {",
            "        ",
            "    },",
            "});",
            "",
            "export default ${1:name}.reducer;",
            "export const { } = ${1:name}.actions;",
            "",
            ""
        ],
        "description": "Create Slice In Redux Toolkit"
    },
    "Axios Base Query In RTK Query": {
        "prefix": "!rtk-axios",
        "body": [
            "import axios form \"axios\"",
            "",
            "const axiosBaseQuery =",
            "    () =>",
            "    async ({ url, method = 'GET', data, params, headers }) => {",
            "        try {",
            "            const result = await axios({ url, method, data, params, headers });",
            "            return { data: result.data };",
            "        } catch (axiosError) {",
            "            let err = axiosError;",
            "            return {",
            "                error: {",
            "                    status: err.response?.status,",
            "                    data: err.response?.data || err.message,",
            "                },",
            "            };",
            "        }",
            "    };",
            "",
            "export default axiosBaseQuery;",
            ""
        ],
        "description": "Axios Base Query In RTK Query"
    },
    "RTK Query Slice API": {
        "prefix": "!rtk-sl",
        "body": [
            "import { createApi } from '@reduxjs/toolkit/query/react';",
            "import axiosBaseQuery from './axiosBaseQuery';",
            "",
            "export const ${1:name} = createApi({",
            "    reducerPath: '${2:pathname}',",
            "    baseQuery: axiosBaseQuery(),",
            "    tagTypes: ['${3:key}'],",
            "    endpoints: (builder) => ({",
            "        ${4:queryFn}: builder.query({",
            "            query: () => ({",
            "                url: '${5:\"\"}',",
            "            }),",
            "            providesTags: (result) => {",
            "                result",
            "                    ? [...result.map((item) => ({ type: 'test', id: item._id })), { type: 'test', id: 'default' }]",
            "                    : [{ type: 'test', id: 'default' }];",
            "            },",
            "        }),",
            "        ${6:mutationFn}: builder.mutation({",
            "            query: (body) => ({",
            "                url: '',",
            "                method: '',",
            "                body,",
            "            }),",
            "            invalidatesTags: (result, err, body) => [{ type: 'test', id: result.id }],",
            "        }),",
            "    }),",
            "});",
            "",
            "export const { } = ${1:name};",
            ""
        ],
        "description": "RTK Query Slice API"
    },
    "Model Default Mongoose": {
        "prefix": "!mgdb-model",
        "body": [
            "const bcrypt = require('bcrypt');",
            "const mongoose = require('mongoose');",
            "const Schema = mongoose.Schema;",
            "",
            "const ${1:Schema} = new Schema(",
            "    {",
            "        username: {",
            "            type: String,",
            "        },",
            "        password: {",
            "            type: String,",
            "        },",
            "    },",
            "    {",
            "        timestamps: true,",
            "    }",
            ");",
            "",
            "// Hash Password before save User",
            "${1:Schema}.pre('save', async function (next) {",
            "    if (!this.isModified('password')) return next();",
            "    const salt = bcrypt.genSaltSync(10);",
            "    this.password = await bcrypt.hash(this.password, salt);",
            "});",
            "",
            "const ${3:Model} = mongoose.model('${2:nameSchema}', ${1:Schema});",
            "module.exports = ${3:Model};",
            ""
        ],
        "description": "Model Default Mongoose"
    },
    "Route Default Mongoose": {
        "prefix": "!expr-route",
        "body": [
            "const express = require('express');",
            "const ${1:router} = express.Router();",
            "",
            "",
            "",
            "module.exports = ${1:router};"
        ],
        "description": "Route Default Mongoose"
    },
    "Connection MongoDB": {
        "prefix": "!mgdb-conn",
        "body": [
            "const mongoose = require('mongoose');",
            "",
            "const MONGODB_URI = ${1:uri};",
            "",
            "const Connection = async () => {",
            "    try {",
            "        await mongoose.connect(MONGODB_URI);",
            "        console.log('Connection successfully !!!');",
            "    } catch (error) {",
            "        console.log('Connection Fail with error: ', error.message);",
            "    }",
            "};",
            "",
            "module.exports = Connection;",
            ""
        ],
        "description": "Connection MongoDB"
    },
    "Config Server And Cookies In NodeJS": {
        "prefix": "!cors",
        "body": [
            "app.use(",
            "    cors({",
            "        origin: '*',",
            "        credentials: true,",
            "    })",
            ");",
            "app.use(cookiesParser());",
            "app.use(express.urlencoded({ extended: true }));",
            "app.use(express.json());",
            "app.use(morgan('common'));"
        ],
        "description": "Config Server And Cookies In NodeJS"
    }
}
